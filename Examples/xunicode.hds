<?xml version="1.0" encoding="utf-8"?>
<hds version="0.3.4" text_encoding="locale" html_encoding="utf-8" tex_encoding="locale" perl_encoding="utf-8">
<node title="XUnicode" open="true">
<para>
既存のアプリケーションをUnicode化するライブラリ。
インフラとしてどんなものにでも組み込めるようにするため
著作権を放棄してパブリックドメインとする。

Cからでも呼び出せるようにするためC++は使わない。
Xlibからの容易な移行を考慮したAPI。
FontSet関連をすべて内部で処理するため、
呼び出し側の改造は最小限に抑えられる。

文字表示だけでなく入力もサポートするため
XIMとUInputクライアント用のコードも含まれる。

コード変換は自前で行うためOSの国際化の差異に影響されない。
これによりオーバーヘッドを最小限に抑える意味もある。
フォントに使われているコードはそれほど多くないことと、
入力はUTF-8決め打ちのため対応コードは限られている。
汎用的なコード変換にはiconvなど別のものの利用が必要となる。

将来の予定
・補助漢字
・文字の合成
・XIMの動的認識
・IIIMP
・コピー＆ペーストでのコード変換

../../xunicode/xunicode.c:2037: warning: `XUChar c2' might be used uninitialize
 in this function                                                              
</para>
<node title="サポートコード">
<para>
以下のフォントがインストールされていれば利用。
基本的にISO 10646を前提として他は補助。
（なくてもないなりに表示はできるという感じ）

iso10646-1
iso8859-1
iso8859-2
koi8-r
jisx0201.1976-0
jisx0208.1983-0
ksc5601.1987-0
gb2312.1980-0
big5-0

Cから呼び出すことを考えると列挙型は使えないが、
マクロで数字化することで参照を容易にする。

#define XU_FONT_COUNT      23
#define XU_FONT_NONE        0
#define XU_FONT_ISO8859(n)  n /* 1-15 */
#define XU_FONT_UNICODE    16
#define XU_FONT_KOI8R      17
#define XU_FONT_JIS0201    18
#define XU_FONT_JIS0208    19
#define XU_FONT_KSC5601    20
#define XU_FONT_GB2312     21
#define XU_FONT_BIG5       22

文字コードはフォントのエンコーディングとは別。

#define XU_CONV_LOCALE     -1
#define XU_CONV_NONE        0
#define XU_CONV_ISO8859(n)  n /* 1-15 */
#define XU_CONV_UTF8       16
#define XU_CONV_KOI8R      17
#define XU_CONV_EUCJP      20
#define XU_CONV_SJIS       21
#define XU_CONV_EUCKR      30
#define XU_CONV_EUCCN      40
#define XU_CONV_BIG5       50

XLFDでのキャラクタセット

static char* xu_charset[XU_FONT_COUNT] =
{
  NULL,
  &quot;iso8859-1&quot;,
  &quot;iso8859-2&quot;,
  &quot;iso8859-3&quot;,
  &quot;iso8859-4&quot;,
  &quot;iso8859-5&quot;,
  &quot;iso8859-6&quot;,
  &quot;iso8859-7&quot;,
  &quot;iso8859-8&quot;,
  &quot;iso8859-9&quot;,
  &quot;iso8859-10&quot;,
  NULL,
  NULL,
  &quot;iso8859-13&quot;,
  &quot;iso8859-14&quot;,
  &quot;iso8859-15&quot;,
  &quot;iso10646-1&quot;,
  &quot;koi8-r&quot;,
  &quot;jisx0201.1976-0&quot;,
  &quot;jisx0208.1983-0&quot;,
  &quot;ksc5601.1987-0&quot;,
  &quot;gb2312.1980-0&quot;,
  &quot;big5-0&quot;
};
</para>
</node>
<node title="構造体">
<para>
DisplayとWindowに対する付加情報を保持するリンクリスト。
絶対数は多くないので線形検索する。

時間がかからないようにする工夫
・新しいものを前に挿入する。
・利用したものは先頭に移動させる。
・フォント名は多いのでハッシュ。

struct _XUInfoFontSetting {
  struct _XUInfoFontSetting* previous;
  struct _XUInfoFontSetting* next;
  char* name;
  int count;
  int order[XU_FONT_COUNT];
  char* font[XU_FONT_COUNT];
};
typedef struct _XUInfoFontSetting XUInfoFontSetting;

struct _XUInfoFont {
  struct _XUInfoFont* previous;
  struct _XUInfoFont* next;
  char* name;
  int count;
  int order[XU_FONT_COUNT];
  Bool none[XU_FONT_COUNT];
  char* fontName[XU_FONT_COUNT];
  XFontStruct* font[XU_FONT_COUNT];
  char* fontSetName;
  XFontSet fontSet;
};
typedef struct _XUInfoFont XUInfoFont;

struct _XUInfoWindow {
  struct _XUInfoWindow* previous;
  struct _XUInfoWindow* next;
  Window window;
  Window topWindow;
  int top, left, width, height;
  XFontStruct* font;
  XFontSet fontSet;
  XIC xic;
  int xicX, xicY;
  Bool xicFocus;
};
typedef struct _XUInfoWindow XUInfoWindow;

struct _XUInfoDisplay {
  struct _XUInfoDisplay* previous;
  struct _XUInfoDisplay* next;
  Display* display;
  XIM xim;
  Window uinput;
  XUInfoWindow* window;
  XUInfoFont* font[256];
  Atom isSrv, setSrv, input, cancel;
  Atom atmFont;
};
typedef struct _XUInfoDisplay XUInfoDisplay;
</para>
</node>
<node title="Atom">
<para>
Unicode Input Serverを処理するためのアトム。

isSrv  = XInternAtom(display, &quot;IsUnicodeInputServer&quot; , False);
setSrv = XInternAtom(display, &quot;SetUnicodeInputServer&quot;, False);
input  = XInternAtom(display, &quot;UnicodeInput&quot;         , False);
cancel = XInternAtom(display, &quot;UnicodeInputCancel&quot;   , False);

クライアント側で必要なAtomはsetSrvとinput。
</para>
</node>
<node title="関数" open="true">
<para>
置き換える関数
・XCloseDisplay  -&gt; XUCloseDisplay
・XDestroyWindow -&gt; XUDestroyWindow
・XDrawString    -&gt; XUDrawString
・XTextExtents   -&gt; XUTextExtents
・XLookupString  -&gt; XULookupString

その他に書き換える部分
・XOpenDisplayの後にXUIMOpen
・XCreateWindowの後にXUUISearch
　（キーイベントを受け取るウィンドウだけ）
・文字幅を求める(XUWidthChar, XUWidthText, XUTextExtents)
・XICを設定する(XUIMSet)
・XICを解除する(XUIMUnset); フォーカスが外れた場合など
・有効なキー入力ならXUUISend
・エディタでの文字移動、文字選択
・イベント処理部分でのXUUI*
</para>
<node title="XUInit">
<para>
初期化
・ロカールの設定
・設定ファイルの読み込み
・逆マップの生成
</para>
</node>
<node title="基本">
<para>
</para>
<node title="XUDebug">
<para>
UTF-8文字列をLocale文字列に変換して出力するprintf。
上限は512文字に制限されている。
最後が'\n'でない場合は改行する。

void XUDebug(const char* fmt, ...);
</para>
</node>
<node title="XUCloseDisplay">
<para>
ディスプレイを閉じる。
XCloseDisplay()の替わりに呼ぶ。

int XUCloseDisplay(Display* display);
</para>
</node>
<node title="XUDestroyWindow">
<para>
ウィンドウを破棄する。
XDestroyWindow()の替わりに呼ぶ。

int XUDestroyWindow(Display* display, Window window);
</para>
</node>
<node title="XUErrorHandler">
<para>
Unicode Input Serverが落ちるとエラーになるので、
それを処理するためのハンドラ。

他のアプリケーションでハンドラを設定している場合は
この関数の中で行っている処理を追加すること。
</para>
</node>
<node title="XUGetWindowPos">
<para>
ウィンドウの位置を取得する。

void
XUGetWindowPos(
  XPoint*  point,
  Display* display,
  Window   window
);

結果はpointに入る。
</para>
</node>
</node>
<node title="表示">
<para>
</para>
<node title="XUDrawString">
<para>
文字を表示する。
入力はUCS-2の配列。

void XUDrawString(
  Display* display,
  Drawable d,
  XFontStruct* font,
  GC gc,
  int x,
  int y,
  const XUChar* string,
  int length,
  Bool erase
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

XDrawString(
  Display* display,
  Drawable d,
  GC gc,
  int x,
  int y,
  const char* string,
  int length
);

[処理]

1. 与えられたfontから名前を取得する
ex. -foo-bar-medium-r-normal--14-130-75-75-c-70-iso8859-1
ISO 8859-1以外が与えられた場合は
単にXDrawString()を呼び出して終了する。

2. 文字ごとに最適なエンコーディングで表示する
eraseがFalseの場合はXDrawString()、
Trueの場合はXDrawImageString()を使用する。
・指定のフォントでUnicodeがあれば使う。
・CJKの文字は非Unicodeフォントを優先する。
</para>
</node>
<node title="XUutf8DrawString">
<para>
文字を表示する。
入力はUTF-8固定。

void XUutf8DrawString(
  Display* display,
  Drawable d,
  XFontStruct* font,
  GC gc,
  int x,
  int y,
  const char* string,
  int length,
  Bool erase
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

UTF-8をUCS-2に変換してXUDrawString()に渡している。
</para>
</node>
</node>
<node title="サイズ">
<para>
</para>
<node title="XUTextExtents">
<para>
文字列のサイズを計算する。
入力はUCS-2の配列。

void
XUTextExtents(
  Display* display,
  XFontStruct* font_struct,
  const XUChar* string,
  int nchars,
  int* direction_return,
  int* font_ascent_return,
  int* font_descent_return,
  XCharStruct* overall_return
);

末端が'\0'となっている文字列を調べる場合は
ncharsに-1を入れることで指定を回避。

XTextExtents(
  XFontStruct* font_struct,
  const char* string,
  int nchars,
  int* direction_return,
  int* font_ascent_return,
  int* font_descent_return,
  XCharStruct* overall_return
);
</para>
</node>
<node title="XUCharWidth">
<para>
文字の幅を返す。

int
XUCharWidth(
  Display* display,
  XFontStruct* font,
  XUChar ch
);

[使用例]
XUChar ch = XUutf8CharEncode(&quot;あ&quot;, -1);
int w = XUCharWidth(display, font, ch);
</para>
</node>
<node title="XUTextWidth">
<para>
文字列の幅を返す。

int
XUTextWidth(
  Display* display,
  XFontStruct* font,
  const XUChar* text,
  int length
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[使用例]
XUChar text[256];
XUutf8Encode(text, 256, &quot;あいうえお&quot;, -1);
int w = XUTextWidth(display, font, text, -1);
</para>
</node>
<node title="XUutf8TextExtents">
<para>
文字列のサイズを計算する。
入力はUTF-8固定。

void
XUutf8TextExtents(
  Display* display,
  XFontStruct* font_struct,
  const char* string,
  int nchars,
  int* direction_return,
  int* font_ascent_return,
  int* font_descent_return,
  XCharStruct* overall_return
);

末端が'\0'となっている文字列を調べる場合は
ncharsに-1を入れることで指定を回避。

UTF-8をUCS-2に変換してXUTextExtents()に渡している。
</para>
</node>
<node title="XUutf8CharWidth">
<para>
文字の幅を返す。

int
XUutf8CharWidth(
  Display* display,
  XFontStruct* font,
  const char* text,
  int length
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[使用例]
int w = XUutf8CharWidth(display, font, &quot;あ&quot;, -1);
</para>
</node>
<node title="XUutf8TextWidth">
<para>
文字列の幅を返す。

int
XUutf8TextWidth(
  Display* display,
  XFontStruct* font,
  const char* text,
  int length
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[使用例]
int w = XUutf8TextWidth(display, font, &quot;あいうえお&quot;, -1);
</para>
</node>
</node>
<node title="フォント">
<para>
</para>
<node title="XUQueryFont">
<para>
対応するフォント名を返す。
エンコーディングはiso8859-1を優先する。
なければ最初に見付けたものとなる。
見付からないときはNULLを返す。

char*
XUQueryFont(
  char* dest,
  int max,
  Display* display,
  const char* family,
  int pixel,
  Bool bold,
  Bool italic
);

[使用例]
char font[256];
XUQueryFont(font, 256, display, &quot;helvetica&quot;, 12, False, False);
/* -adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1 */
</para>
</node>
<node title="XULoadQueryFont">
<para>
対応するフォントを返す。
エンコーディングはiso8859-1を優先する。
なければ最初に見付けたものとなる。

XFontStruct*
XULoadQueryFont(
  Display* display,
  const char* family,
  int pixel,
  Bool bold,
  Bool italic
);

XFontStruct*
XLoadQueryFont(
  Display* display,
  const char* name
);

[使用例]
XFontStruct* font = XULoadQueryFont(display, &quot;helvetica&quot;, 12, False, False);
/* -adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1 */
</para>
</node>
<node title="XUSearchFont">
<para>
キャラクタセットを入れ替えたフォント名を返す。
見付からないときはNULLを返す。

char*
XUSearchFont(
  char* dest,
  int max,
  Display* display,
  const char* font,
  int code
);

[使用例]
const char* orig = &quot;-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1&quot;;
char font[256];
XUSearchFont(font, 256, display, orig, XU_FONT_JIS0208);
/* -misc-fixed-medium-r-normal--14-130-75-75-c-140-jisx0208.1983-0 */
</para>
</node>
<node title="XULoadSearchFont">
<para>
キャラクタセットを入れ替えたフォントを返す。
見付からないときはNULLを返す。

XFontStruct*
XULoadSearchFont(
  Display* display,
  const char* font,
  int code
);

[使用例]
const char* orig = &quot;-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1&quot;;
XFontSet* font = XULoadSearchFont(display, orig, XU_FONT_JIS0208);
/* -misc-fixed-medium-r-normal--14-130-75-75-c-140-jisx0208.1983-0 */
</para>
</node>
<node title="XUCompareFonts">
<para>
fontsの中からfontに最も近いフォントを選ぶ。
エンコーディングは無視される。

char*
XUCompareFonts(
  char* dest,
  int max,
  const char* font,
  char* fonts[],
  int count
);
</para>
</node>
<node title="XUGetFontName">
<para>
対応するフォントのXLFD名を返す。
エンコーディングはiso8859-1を優先する。
なければ最初に見付けたものとなる。
戻り値は使用後にXFree()して解放する必要がある。

char* XUGetFont(Display* display, XFontStruct* font);

[使用例]
char* font = XUGetFont(d, f);
/* -adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1 */
XFree(font);
</para>
</node>
<node title="XUGetFontSet">
<para>
設定ファイルの作成などに応用するための関数。
与えられたフォントを基にフォントセットを作成して
フォントリストを文字列で返す。
区切り文字を指定することができる。

char*
XUGetFontSet(
  char* dest,
  int max,
  const char* separator,
  Display* display,
  const char* font
);

[使用例]
char fontset[512];
XUGetFontSet(
  fontset, 512, &quot;,&quot;, display,
  &quot;-adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1&quot;
);
</para>
</node>
<node title="XUCreateFontSet">
<para>
与えられたフォントを基にフォントセットを作成する。
XIMを利用するためだけに存在する関数で、
XUIMFont()から呼ばれる。

与えるフォント名はベースとなるISO 8859-1のみ。
ex. -foo-bar-medium-r-normal--14-130-75-75-c-70-iso8859-1

XCreateFontSetは呼び出しが大変なので
手軽に行うという側面もある。

XFontSet
XUCreateFontSet(
  Display* display,
  XFontStruct* font
);

XFontStruct*
XLoadQueryFont(
  Display* display,
  char* name
);

XFontSet
XCreateFontSet(
  Display* display,
  char*    base_font_name_list,
  char***  missing_charset_list_return,
  int*     missing_charset_count_return,
  char**   def_string_return
);
</para>
</node>
</node>
<node title="文字">
<para>
</para>
<node title="XUCharEncode">
<para>
文字コードを指定した文字列の中の1文字を
Unicode番号に変換する。

XUChar
XUCharEncode(
  const char* text,
  int max,
  int code
);

末端が'\0'となっている文字列を調べる場合は
maxに-1を入れることで指定を回避。

[使用例]
XUChar c = XUCharEncode(&quot;あ&quot;, -1, XU_CONV_EUCJP);
/* c == 0x3042 */
</para>
</node>
<node title="XUCharDecode">
<para>
Unicode番号から指定した文字コードの文字列を
生成して長さを返す。
maxが足りない場合はdestを変更しない。

int
XUCharDecode(
  char* dest,
  int max,
  XUChar ch,
  int code
);

[使用例]
char text[16];
XUCharDecode(text, 16, 0x3042, XU_CONV_EUCJP);
</para>
</node>
<node title="XUCharLen">
<para>
指定された文字コードの文字列の中の1文字のバイト長を返す。

int XUCharLen(const char* text, int max, int code);

末端が'\0'となっている文字列を調べる場合は
maxに-1を入れることで指定を回避。

const char* text = &quot;あ&quot;;
int len = XUCharLen(text, -1, XU_CONV_EUCJP);
</para>
</node>
<node title="XUutf8CharEncode">
<para>
UTF-8文字列の中の1文字をUnicode番号に変換する。

XUChar XUutf8CharEncode(const char* text, int max);

末端が'\0'となっている文字列を調べる場合は
maxに-1を入れることで指定を回避。

[使用例]
XUChar c = XUutf8CharEncode(&quot;あ&quot;, -1);
/* c == 0x3042 */
</para>
</node>
<node title="XUutf8CharDecode">
<para>
Unicode番号からUTF-8文字列を生成して長さを返す。
maxが足りない場合はdestを変更しない。

int XUutf8CharDecode(char* dest, int max, XUChar ch);

[使用例]
char utf8[16];
XUutf8CharDecode(utf8, 16, 0x3042);
</para>
</node>
<node title="XUutf8CharLen">
<para>
UTF-8文字列の中の1文字のバイト長を返す。

int XUutf8CharLen(const char* text, int max);

末端が'\0'となっている文字列を調べる場合は
maxに-1を入れることで指定を回避。

const char* text = &quot;あ&quot;;
int len = XUutf8CharLen(text, -1);
</para>
</node>
<node title="XUutf8CharRLen">
<para>
UTF-8文字列の中の1つ前の1文字のバイト長を返す。

int XUutf8CharRLen(const char* text, int max);

逆向きのため他の物のようにmaxに-1を入れることはできない。

const char* text = &quot;ああ&quot;;
int len = XUutf8CharLen(text, -1);
const char* p1 = text + len;
const char* p2 = p1 - XUutf8CharRLen(p1, len);
/* text == p2 */
</para>
</node>
</node>
<node title="文字列">
<para>
</para>
<node title="XUStrLen">
<para>
文字列の長さを返す。

int XUStrLen(const XUChar* text);
</para>
</node>
<node title="XUEncode">
<para>
他のコードからUnicodeに変換する。
maxが足りない場合でも長さは理論値を返す。

XIMのためだけに存在するような関数なので、
あまり多くのコードはサポートしていない。
本格的な変換にはiconvなどを利用すべき。

int XUEncode(
  XUChar* dest,
  int max,
  const char* text,
  int length,
  int code
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[利用例] (EUC-JP -&gt; Unicode)
XUChar text[256];
XUEncode(text, 256, &quot;あいうえお&quot;, -1, XU_CONV_EUCJP);
</para>
</node>
<node title="XUDecode">
<para>
Unicodeから他のコードに変換する。
maxが足りない場合でも長さは理論値を返す。

XUEncodeとのバランスのために存在する関数。
本格的な変換にはiconvなどを利用すべき。

int XUDecode(
  char* dest,
  int max,
  const XUChar* text,
  int length,
  int code
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[利用例] (Unicode -&gt; EUC-JP)
XUChar text[256];
XUUnicode(text, 256, &quot;あいうえお&quot;, -1);
char eucjp[256];
XUEncode(eucjp, 256, text, -1, XU_CONV_EUCJP);
</para>
</node>
<node title="XULen">
<para>
指定した文字コードの文字列の文字の個数を返す。

int XULen(const char* text, int max, int code);

末端が'\0'となっている文字列を調べる場合は
maxに-1を入れることで指定を回避。

int len = XULen(&quot;あああ&quot;, -1, XU_CONV_EUCJP);
/* len == 3 */
</para>
</node>
<node title="XUutf8Encode">
<para>
UTF-8からUCS-2に変換する。
maxが足りない場合でも長さは理論値を返す。

int XUutf8Encode(
  XUChar* dest,
  int max,
  const char* text,
  int length
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[利用例]
XUChar text[256];
XUutf8Encode(text, 256, &quot;あいうえお&quot;, -1);
</para>
</node>
<node title="XUutf8Decode">
<para>
UCS-2からUTF-8に変換する。
maxが足りない場合でも長さは理論値を返す。

int XUutf8Decode(
  char* dest,
  int max,
  const char* text,
  int length
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[利用例]
XUChar text[256];
char utf8[256];
XUutf8Encode(text, 256, &quot;あいうえお&quot;, -1);
XUutf8Decode(utf8, 256, text, -1);
</para>
</node>
<node title="XUutf8Len">
<para>
UTF-8文字列の文字の個数を返す。

int XUutf8Len(const char* text, int max);

末端が'\0'となっている文字列を調べる場合は
maxに-1を入れることで指定を回避。

int len = XUutf8Len(&quot;あああ&quot;, -1);
/* len == 3 */
</para>
</node>
<node title="XUCodeConv">
<para>
文字コードを変換する。
maxが足りない場合でも長さは理論値を返す。

int XUCodeConv(
  char* dest,
  int max,
  int codeTo,
  const char* text,
  int length,
  int codeFrom
);

末端が'\0'となっている文字列を調べる場合は
lengthに-1を入れることで指定を回避。

[利用例]
char eucjp[256];
XUCodeConv(
  eucjp, 256, XU_CONV_EUCJP,
  &quot;あいうえお&quot;, -1, XU_CONV_UTF8
);
</para>
</node>
</node>
<node title="IM">
<para>
</para>
<node title="XUIMOpen">
<para>
XIMを開く。
XOpenDisplay()の後に呼び出す。

Bool XUIMOpen(Display* display);
</para>
</node>
<node title="XUIMSet">
<para>
XICをフォーカスしてOverTheSpotの位置を指定する。
XICがない場合は作成する。
フォントが先に指定されていない場合は失敗してFalseを返す。

Bool XUIMSet(
  Display* display,
  Window window,
  XFontStruct* font,
  int left,
  int top,
  int width,
  int height,
  int x,
  int y
);
</para>
</node>
<node title="XUIMUnset">
<para>
XICのフォーカスを解除する。
XICがない場合は何も起こらない。

void XUIMUnset(Display* display, Window window);
</para>
</node>
<node title="XULookupString">
<para>
入力された文字をUnicodeで返す。
XICが存在するならIMから情報を取得する。
内部でXFilterEvent()によるチェックも行う。

int
XULookupString(
  Display*        display,
  Window          window,
  XEvent*         event_struct,
  XUChar*         buffer_return,
  int             bytes_buffer,
  KeySym*         keysym_return,
  XComposeStatus* status_in_out
);

int
XLookupString(
  XKeyEvent*      event_struct,
  char*           buffer_return,
  int             bytes_buffer,
  KeySym*         keysym_return,
  XComposeStatus* status_in_out
);

int
XmbLookupString(
  XIC ic,
  XKeyPressedEvent* event,
  char*             buffer_return,
  int               bytes_buffer,
  KeySym*           keysym_return,
  Status*           status_return
);
</para>
</node>
<node title="XUutf8LookupString">
<para>
入力された文字をUTF-8で返す。
XICが存在するならIMから情報を取得する。
内部でXFilterEvent()によるチェックも行う。

int
XUutf8LookupString(
  Display*        display,
  Window          window,
  XEvent*         event_struct,
  char*           buffer_return,
  int             bytes_buffer,
  KeySym*         keysym_return,
  XComposeStatus* status_in_out
);
</para>
</node>
</node>
<node title="Unicode Input">
<para>
</para>
<node title="XUUISearch">
<para>
Unicode Input Serverを探す。
結果は指定したウィンドウにClientMessageとして返される。

void XUUISearch(Display* display, Window window);
</para>
</node>
<node title="XUUISet">
<para>
Unicode Input Serverをセットする。
ClientMessageで&quot;SetUnicodeInputServer&quot;が届いた時に呼ぶ。

void XUUISet(Display* display, const XEvent* event);
</para>
</node>
<node title="XUUISend">
<para>
Unicode Input Serverへイベントを送る。
ServerのないDisplayではFalseを返す。

Bool
XUUISend(
  Display* display,
  Window window,
  const XEvent* event
);

KeyPress, KeyReleaseの両方を送る。
</para>
</node>
<node title="XUUICancel">
<para>
Unicode Input Serverの入力をキャンセルする。
ServerのないDisplayではFalseを返す。

以下の状況で呼ぶようにする。
・マウスがクリックされた
・フォーカスが外れた
・ウィンドウが破棄される &lt;- XUDestroyWindow()

Bool XUUICancel(Display* display);
</para>
</node>
</node>
<node title="内部情報">
<para>
</para>
<node title="XUGetInfoDisplay">
<para>
ディスプレイの情報を取得する。
対象項目は検索の最適化のため自動的に先頭に移動。
内部で使用するため特に外部から呼ぶ必要はない。

XUInfoDisplay* XUGetInfoDisplay(Display* display);
</para>
</node>
<node title="XUGetInfoWindow">
<para>
ウィンドウの情報を取得する。
対象項目は検索の最適化のため自動的に先頭に移動。
内部で使用するため特に外部から呼ぶ必要はない。

XUInfoWindow*
XUGetInfoWindow(
  Display* display,
  Window   window
);
</para>
</node>
<node title="XUGetInfoFont">
<para>
フォントの情報を取得する。
対象項目は検索の最適化のため
ハッシュした上で自動的に先頭に移動。
内部で使用するため特に外部から呼ぶ必要はない。

XUInfoFont*
XUGetInfoFont(
  Display* display,
  const char* font
);
</para>
</node>
<node title="XUFreeInfoFont">
<para>
フォント情報を削除する。

void XUFreeInfoFont(Display* display, XUInfoFont* font);
</para>
</node>
</node>
</node>
<node title="設定ファイル" open="true">
<para>
以下の優先度でファイルを調べる
LANGはLocaleのうち言語名のみを指す
ja_JP.eucJP → ja

~/.xunicoderc.LANG
~/.xunicoderc
/usr/local/etc/xunicoderc.LANG
/usr/local/etc/xunicoderc
/etc/xunicoderc.LANG
/etc/xunicoderc
~/.qti18nrc

ファミリー名ごとに指定する。
Unicode上のマップが重なる場合は、
優先順位は記述された順番になる。

指定されない場合は自動検索される。
デフォルトは*で指定する。
</para>
<node title="例">
<para>
fixed     -alias-fixed-*-jisx0201.1976-0, \
          -alias-fixed-*-jisx0208.1983-0, \
          -daewoo-gothic-*-ksc5601.1987-0, \
          -isas-fangsong ti-*-gb2312.1980-0, \
          -kc-fixed-*-big5-0
courier   -alias-fixed-*-jisx0201.1976-0, \
          -alias-fixed-*-jisx0208.1983-0, \
          -daewoo-mincho-*-ksc5601.1987-0, \
          -isas-song ti-*-gb2312.1980-0, \
          -kc-fixed-*-big5-0, \
          -schumacher-clean-*-iso10646-1
helvetica -dynalab-dfgothicp-*-jisx0201.1976-0, \
          -dynalab-dfgothicp-*-jisx0208.1983-0, \
          -daewoo-gothic-*-ksc5601.1987-0, \
          -isas-fangsong ti-*-gb2312.1980-0, \
          -kc-fixed-*-big5-0
*         -dynalab-dfminchop-*-jisx0201.1976-0, \
          -dynalab-dfminchop-*-jisx0208.1983-0, \
          -daewoo-mincho-*-ksc5601.1987-0, \
          -isas-song ti-*-gb2312.1980-0, \
          -kc-fixed-*-big5-0
</para>
</node>
</node>
<node title="説明">
<para>
Cだけで書いたためメモリ割り当ての問題があって
マクロでの文字変換は不可能。

EUCでソースを書いたときは
iconvでコンパイル前にUTF-8に変換しておく。
WindowsでEUCからSJISに変換しているが、
それと同じことだと考えれば問題ないと思う。

UTF-8対応のエディタも提供できれば最良。

このコードはパブリックドメインとしますので、
私は一切著作権を主張いたしません。
組み込んだコードに独自の著作権を付与することは自由です。
これはこのレベルの処理は最低限のインフラだと考えるからです。

これはXutf8*()でやろうとしたことにかなり似ています。
Xに組み込むわけではないので3.3.xでも利用できます。

そういえばXFree86-4.0.2ではXutf8*()が入れられた替わりに
X Localeが取り除かれてしまったので、
Darwinで日本語が入力できなくなって困りました。
そのため古いものを取って来る羽目になりました。
</para>
</node>
<node title="メモ">
<para>
日本語化に必要なこと。
・日本語の表示
・日本語の入力

今どうせやるなら日本語化ではなくUnicode化にするべき。
そうすれば汎用性も高い。

なぜXの関数でやたらにDisplay*が必要なのか疑問に思っていたが、
同時に複数のサーバに接続することが前提だからだった。

たとえば仮にWindowの値が同じでも
別のサーバに存在する別物である可能性があるため、
Windowを指定する時には同時にDisplayも指定しないといけない。

OnTheSpot入力をどうやってサポートするか？
Localeを無視して独自プロトコルで通信したい。(IIIMP?)

SALが生成したC++のソースをCに変更する手順
1. 配列変数の自動初期化をやめる
2. 変数の初期化を直す
ex. XUChar ret(0); → XUChar ret = 0;
</para>
<node title="XLFD">
<para>
 0: fndry(adobe)
 1: fmly(helvetica)
 2: wght(medium)
 3: slant(r)
 4: sWdth(normal)
 5: adstyl()
 6: pxlsz(14)
 7: ptSz(140)
 8: resx(75)
 9: resy(75)
10: spc(p)
11: avgWdth(77)
12: rgstry(iso8859)
13: encdng(1)

-adobe-helvetica-medium-r-normal--14-140-75-75-p-77-iso8859-1
</para>
</node>
<node title="文字コード">
<para>
JIS0208: 0x21-0x74; 0x21-0x7E (84 *  94 =  7896)
GB2312 : 0x21-0x77; 0x21-0x7E (87 *  94 =  8178)
Big5   : 0xA1-0xF9; 0x40-0x7E, 0xA1-0xFE (89 * 157 = 13973)
KSC5601: 0x81-0xC8; 0x41-0x5A, 0x61-0x7A, 0x81-0xFE (72 * 178 = 12816)
         0xCA-0xFD; 0xA1-0xFE (52 *  94 =  4888)
</para>
</node>
<node title="UTF-8">
<para>
0x00000000 - 0x0000007F:
  0xxxxxxx

0x00000080 - 0x000007FF: 0xc0-0xdf
  110xxxxx 10xxxxxx
c[0] &lt; 0xc2

0x00000800 - 0x0000FFFF: 0xe0-0xef
  1110xxxx 10xxxxxx 10xxxxxx
c[1] &lt; 0x20 &amp;&amp; c[0] &lt; 0xe1

0x00010000 - 0x001FFFFF: 0xf0-0xf7
  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
c[1] &lt; 0x10 &amp;&amp; c[0] &lt; 0xf1

0x00200000 - 0x03FFFFFF: 0xf8-0xfb
  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
c[1] &lt; 0x08 &amp;&amp; c[0] &lt; 0xf9

0x04000000 - 0x7FFFFFFF: 0xfc, 0xfd
  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
c[1] &lt; 0x04 &amp;&amp; c[0] &lt; 0xfd
</para>
</node>
<node title="ISO8859">
<para>
ISO 8859-1 : U+0080-U+00FF: 西欧
ISO 8859-2 : U+0080-U+02DD: 東欧
ISO 8859-3 : U+0080-U+02D9: トルコ、エスペラント
ISO 8859-4 : U+0080-U+02DB: バルト
ISO 8859-5 : U+0080-U+045F: キリル
ISO 8859-6 : U+0080-U+0652: アラビア, U+2116
ISO 8859-7 : U+0080-U+03CE: ギリシア, U+2015, U+2018, U+2019
ISO 8859-8 : U+0080-U+05EA: ヘブライ, U+200E, U+200F, U+2017
ISO 8859-9 : U+0080-U+015F: トルコ
ISO 8859-10: U+0080-U+017E: バルト2, U+2015
ISO 8859-13: U+0080-U+017E, U+2019, U+201C, U+201D, U+201E
ISO 8859-14: U+0080-U+0178, U+01E02..U+1EF3
ISO 8859-15: U+0080-U+017E: 西欧2(ユーロ), U+20AC

ISO 8859-1とISO 8859-15の違い
0xa4: U+20AC
0xa6: U+0160
0xa8: U+0161
0xb4: U+017D
0xb8: U+017E
0xbc: U+0152
0xbd: U+0153
0xbe: U+0178

static unsigned short table_rev_iso8859_2[1024];
</para>
</node>
<node title="KOI8-R">
<para>
KOI8-R: KOI8のロシア語版。

U+00A0-U+0451
U+2219-U+25A0

static unsigned short table_rev_koi8r_1[1024];
static unsigned short table_rev_koi8r_2[1024];

0080-, 2200-
</para>
</node>
<node title="JIS0201">
<para>
[半角仮名]
0x00a1-0x00df: JIS0201
U+FF61-U+FF9F: Unicode
差分: 0xfec0
EUC: 0x8e 0xXX
</para>
</node>
<node title="Shift JIS">
<para>
8140:2121 - 9FFC:5E7E
E040:5F21 - FCFC:987E(?)

8540:85DD(0021-00DF)
(287E)2921-2A5F(2A60-)

JIS  (21-98)+(21-7E)
SJIS (81-9F,E0-FC)+(40-7E,80-FC)

SJISの下位はJISの2倍
[21-7E]
1. 40-7E,80-9E
2. 9F-FC
</para>
</node>
<node title="Unicode">
<para>
U+0000..U+007F: Basic Latin
U+0080..U+00FF: Latin-1 Supplement
U+0100..U+017F: Latin Extended-A
U+0180..U+024F: Latin Extended-B
U+0250..U+02AF: IPA Extensions
U+02B0..U+02FF: Spacing Modifier Letters
U+0300..U+036F: Combining Diacritical Marks
U+0370..U+03FF: Greek
U+0400..U+04FF: Cyrillic
U+0530..U+058F: Armenian
U+0590..U+05FF: Hebrew
U+0600..U+06FF: Arabic
U+0700..U+074F: Syriac
U+1100..U+11FF: Hangul Jamo
U+1E00..U+1EFF: Latin Extended Additional
U+1F00..U+1FFF: Greek Extended
U+2000..U+206F: General Punctuation
U+2070..U+209F: Superscripts and Subscripts
U+20A0..U+20CF: Currency Symbols
U+20D0..U+20FF: Combining Marks for Symbols
U+2100..U+214F: Letterlike Symbols
U+3000..U+303F: CJK Symbols and Punctuation
U+3040..U+309F: Hiragana
U+30A0..U+30FF: Katakana
U+3400..U+4DB5: CJK Unified Ideographs Extension A
U+4E00..U+9FFF: CJK Unified Ideographs
U+AC00..U+D7A3: Hangul Syllables
U+FF00..U+FFEF: Halfwidth and Fullwidth Forms
</para>
</node>
<node title="Public Domain">
<para>
/* 
 * This software is in the public domain.
 * There are no restrictions on any sort of usage of this software.
 */
</para>
</node>
<node title="古い情報">
<para>
ツールキットをXUnicode対応にする手順。
※マクロによりオリジナルを破壊しないよう留意すること

1. XOpenDisplayをxulib.display()で代用
   XCloseDisplayをフィルタ
2. XFontStruct -&gt; XUFont, XLoadQueryFont置換
3. XTextExtents() -&gt; XUFont::textWidth()
4. XDrawString() -&gt; XUFont::print()
5. テキストウィジェットでのカーソル移動を補正
6. WindowをXUWindowに関連付け
7. XIM, XIC関連をXUnicodeに移行
8. キーイベントの解釈にXUIC::input()を使用
9. UInputプロトコルの実装
</para>
</node>
</node>
<node title="コード例">
<para>
XIC On/Off
XSetICFocus(xic);
XUnsetICFocus(xic);
</para>
<node title="フォント名取得">
<para>
#include &lt;X11/Xlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;

bool str(const char* a)
{
  if(!strcmp(a, &quot;FOUNDRY&quot;         )) return true;
  if(!strcmp(a, &quot;FAMILY_NAME&quot;     )) return true;
  if(!strcmp(a, &quot;WEIGHT_NAME&quot;     )) return true;
  if(!strcmp(a, &quot;SLANT&quot;           )) return true;
  if(!strcmp(a, &quot;SETWIDTH_NAME&quot;   )) return true;
  if(!strcmp(a, &quot;ADD_STYLE_NAME&quot;  )) return true;
  if(!strcmp(a, &quot;SPACING&quot;         )) return true;
  if(!strcmp(a, &quot;CHARSET_REGISTRY&quot;)) return true;
  if(!strcmp(a, &quot;CHARSET_ENCODING&quot;)) return true;
  if(!strcmp(a, &quot;COPYRIGHT&quot;       )) return true;
  if(!strcmp(a, &quot;FONT&quot;            )) return true;
  return false;
}

main()
{
  setlocale(LC_ALL, &quot;&quot;);
  XSetLocaleModifiers(&quot;&quot;);
  Display* d = XOpenDisplay(&quot;&quot;);
  if(!d) exit(1);
  XFontStruct* f;
  f = XLoadQueryFont(d, &quot;7x14&quot;);
  char* a1;
  char* a2;
  XFontProp* p = f-&gt;properties;
  for(int i = 0; i &lt; f-&gt;n_properties; i++, p++){
    a1 = XGetAtomName(d, p-&gt;name);
    if(str(a1)){
      a2 = XGetAtomName(d, p-&gt;card32);
      printf(&quot;%s: %s\n&quot;, a1, a2);
      XFree(a2);
    }else{
      printf(&quot;%s: %d\n&quot;, a1, p-&gt;card32);
    }
    XFree(a1);
  }
  XFreeFont(d, f);
}
</para>
</node>
<node title="フォント列挙">
<para>
#include &lt;X11/Xlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;

main()
{
  setlocale(LC_ALL, &quot;&quot;);
  XSetLocaleModifiers(&quot;&quot;);
  Display* d = XOpenDisplay(&quot;&quot;);
  if(!d) exit(1);
  int count;
  char** fn = XListFonts(d, &quot;*-jisx0208.1983-0&quot;, 256, &amp;count);
  for(int i = 0; i &lt; count; i++){
    printf(&quot;%s\n&quot;, fn[i]);
  }
  XFreeFontNames(fn);
}
</para>
</node>
<node title="フォント比較">
<para>
static QString compare_fonts(const QString&amp; fn, char* l[], int n)
{
  QCString buffer1(256);
  QCString buffer2(256);
  char* tokens1[fontFields];
  char* tokens2[fontFields];
  QString ret;
  strcpy(buffer1.data(), fn.latin1());
  if(!qParseXFontName(buffer1, tokens1)) return ret;
  
  int v, s1a, s1b, s2, sz, max, no;
  max = -1;
  no  = -1;
  s1a = atoi(tokens1[PixelSize]);
  s1b = atoi(tokens1[PointSize]);
  for(int i = 0; i &lt; n; i++){
    strcpy(buffer2.data(), l[i]);
    if(!qParseXFontName(buffer2, tokens2)) continue;
    v = 0;
    if(!strcmp(tokens1[Slant  ], tokens2[Slant  ])) v += 400;
    if(!strcmp(tokens1[Weight_], tokens2[Weight_])) v += 200;
    if(!strcmp(tokens1[Family ], tokens2[Family ])) v += 100;
    if(s1a){
      s2 = atoi(tokens2[PixelSize]);
      sz = s1a - s2;
    }else{
      s2 = atoi(tokens2[PointSize]);
      sz = int((s1b - s2) / 10);
    }
    if(sz &lt;  0) sz = 8 - sz;
    if(sz &gt; 98) sz = 98;
    sz = 98 - sz;
    if(sz == 98) sz = 99;
    if(s2 == 0 &amp;&amp; atoi(tokens2[ResolutionX]) == 0) sz = 98;
    v += sz;
    if(max &lt; v){
      max = v;
      no  = i;
    }
  }
  if(no &lt; 0) return ret;
  
  strcpy(buffer2.data(), l[no]);
  if(!qParseXFontName(buffer2, tokens2)) return l[no];
  if(atoi(tokens2[PixelSize]) != 0) return l[no];
  
  if(s1a){
    ret.sprintf(
      &quot;-%s-%s-%s-%s-%s-%s-%i-0-0-0-%s-0-%s-%s&quot;,
      tokens2[Foundry ],
      tokens2[Family  ],
      tokens2[Weight_ ],
      tokens2[Slant   ],
      tokens2[Width   ],
      tokens2[AddStyle],
      s1a,
      tokens2[Spacing ],
      tokens2[CharsetRegistry],
      tokens2[CharsetEncoding]
    );
  }else{
    ret.sprintf(
      &quot;-%s-%s-%s-%s-%s-%s-0-%i-0-0-%s-0-%s-%s&quot;,
      tokens2[Foundry ],
      tokens2[Family  ],
      tokens2[Weight_ ],
      tokens2[Slant   ],
      tokens2[Width   ],
      tokens2[AddStyle],
      s1b,
      tokens2[Spacing ],
      tokens2[CharsetRegistry],
      tokens2[CharsetEncoding]
    );
  }
  return ret;
}
</para>
</node>
<node title="文字入力">
<para>
char buf[256];
Status st;
KeySym ks;
int len;
if(xic) {
  len = XmbLookupString(xic, e-&gt;xkey, buf, 255, &amp;ks, &amp;st);
} else {
  len = XLookupString(e-&gt;xkey, buf, 255, &amp;ks, NULL);
}
buf[len] = 0;
</para>
</node>
<node title="サイズ取得">
<para>
static void unicode_text_extents1(
  const QFont&amp; f, XFontStruct* ff, XFontStruct* uf,
  EncodingType enc, XChar2b* s, int l, XCharStruct* overall)
{
  XFontStruct* fs = NULL;
  if(enc == encUnicode){
    if(uf) fs = uf;
    else   fs = search_font_for_encoding(f.rawName(), &quot;iso10646-1&quot;);
  }else if(enc != encIso8859_1){
    fs = search_font_for_encoding(f.rawName(), get_encoding_name(enc));
  }
  if(!fs){
    fs = ff;
    if(enc != encIso8859_1){
      XChar2b* ss = s;
      for(int i = 0; i &lt; l; i++, ss++){
        ss-&gt;byte1 = 0;
        ss-&gt;byte2 = '?';
      }
    }
  }
  if(!fs) return;
  
  int dir     = 0;
  int ascent  = 0;
  int descent = 0;
  XCharStruct oa;
  XTextExtents16(fs, s, l, &amp;dir, &amp;ascent, &amp;descent, &amp;oa);
  if(!overall-&gt;width) overall-&gt;lbearing = oa.lbearing;
  overall-&gt;rbearing = overall-&gt;width + oa.rbearing;
  if(overall-&gt;ascent  &lt; oa.ascent ) overall-&gt;ascent  = oa.ascent;
  if(overall-&gt;descent &lt; oa.descent) overall-&gt;descent = oa.descent;
  overall-&gt;width += oa.width;
}

void unicode_text_extents(
  const QFont&amp; f, XFontStruct* fs,
  const QString&amp; s, int l, XCharStruct* overall)
{
  if(!overall) return;
  
  overall-&gt;lbearing = 0;
  overall-&gt;rbearing = 0;
  overall-&gt;ascent   = 0;
  overall-&gt;descent  = 0;
  overall-&gt;width    = 0;
  if(l &lt; 1) return;
  
  XFontStruct* uf = swap_unicode_font(f);
  XChar2b* mb = new XChar2b[l];
  XChar2b* mbp = mb;
  EncodingType enc, enc2 = encUnknown;
  unsigned int ch;
  int ll = 0;
  for(int i = 0; i &lt; l; i++){
    ch = s[i].unicode();
    enc = encUnknown;
    if(ch &lt; 0x1000){
      if(uf){
        enc = encUnicode;
      }else if(have_unicode_font &amp;&amp; ch &gt;= 0x0100){
        enc = encUnicode;
      }
    }
    if(enc == encUnknown){
      enc = unicode_char_encoding(ch);
      ch  = encode_unicode_char(ch);
    }
    if(enc2 == encUnknown) enc2 = enc;
    if(enc2 != enc){
      unicode_text_extents1(f, fs, uf, enc2, mb, ll, overall);
      mbp = mb;
      ll = 0;
      enc2 = enc;
    }
    mbp-&gt;byte1 = ch &gt;&gt; 8;
    mbp-&gt;byte2 = ch &amp; 0xff;
    mbp++;
    ll++;
  }
  unicode_text_extents1(f, fs, uf, enc2, mb, ll, overall);
  delete mb;
}
</para>
</node>
</node>
<node title="組み込み例" open="true">
<para>
基本的な改造の手順

1. 初期化部分を見付ける
2. 文字が表示できるようにする
3. カーソル移動がきちんとできるようにする
4. XIMが使えるようにする
5. uinputが使えるようにする
</para>
<node title="FLTK">
<para>
  ---- 基本 ----

USE_XUNICODEマクロによりセットする。
% env CXXFLAGS=-DUSE_XUNICODE ./configure
% env CXXFLAGS=-DUSE_XUNICODE X_EXTRA_LIBS=-lxpg4 ./configure

・初期化
Fl_x.cxx: fl_open_display()
XUInit()を埋め込む
XOpenDisplay()の後にXUIMOpen()を追加
fl_displayに対してfl_info_displayを追加

・単純な置き換え
Fl.cxx: XDestroyWindow() -&gt; XUDestroyWindow()
Fl_x.cxx: XCloseDisplay() -&gt; XUCloseDisplay()
fl_info_displayもNULLにする。


  ---- 表示 ----

・文字表示のUTF-8化
fl_font.cxx: XDrawString() -&gt; XUutf8DrawString()

・文字幅処理の置き換え
fl_font.cxx: fl_width()内でXUTextWidth()

・文字ごとに処理する部分を修正
Fl_Input_.cxx: Fl_Input_::expand(), expandpos()
下手をするとパスワードモードがフリーズするので注意。
fl_draw.cxx: expand()
XUutf8CharEncode(), XUutf8CharLen()


  ---- 編集 ----

・カーソル移動、削除の補正
Fl_Input_.cxx: Fl_Input_::handle_mouse()
Fl_Input.cxx: Fl_Input::handle_key()
XUutf8CharLen(), XUutf8CharRLen()

文字列のポインタ: &amp;value()[pos]
サイズ: size()


  ---- XIM ----

・イベント処理
Fl_x.cxx: fl_handle()
KeyPressで文字取得はXUutf8LookupString()

・XIC処理関数
Fl_x.cxx: fl_set_xic_focus(), fl_unset_xic_focus()を追加

・XICオン
Fl_Input_.cxx: Fl_Input_::drawtext()
キャレットを表示する時にfl_set_xic_focus()
※setfont()を呼ぶとfl_xfontがセットされる。

・XICオフ
Fl_Input.cxx: Fl_Input::handle()
フォーカスが外れた(FL_UNFOCUS)時にfl_unset_xic_focus()


  ---- uinput ----

変な所で有効にならないように
XIMが有効なウィンドウでだけ有効にする。

・エラー処理
Fl_x.cxx: xerror_handler

・サーバに接続
Fl_x.cxx: XCreateWindow()の後にXUUISearch()

・イベント処理
Fl_x.cxx: fl_handle()
キー入力後にXUUISend()
ClientMessageでの処理(setSrvとinput)

・FLTK側の実装(compose)を無効化
Fl_compose.cxx: Fl::compose()
compose_stateが1にならないようにする。


  ---- 結果 ----

サイズは120KBほど増加。

[例] editor
219,754(120,788) -&gt; 347,605(243,508)
カッコ内はstripしたサイズ
</para>
</node>
<node title="FLTK2">
<para>
Fl_Text_BufferのAPIがUTF-8化に適していない。

static int Fl_Text_Buffer::expand_character(
  char c,
  int indent, char* outStr, int tabDist, char nullSubsChar);

static int Fl_Text_Buffer::character_width(
  char c,
  int indent, int tabDist, char nullSubsChar);

  ----

static int Fl_Text_Buffer::expand_character(
  const char* c, int length,
  int indent, char* outStr, int tabDist, char nullSubsChar);

static int Fl_Text_Buffer::character_width(
  const char* c, int length,
  int indent, int tabDist, char nullSubsChar);
</para>
</node>
<node title="JX">
<para>
</para>
</node>
<node title="FOX">
<para>
  ---- 基本 ----

USE_UNICODEマクロによりセットする。
% env X_CFLAGS=-DUSE_UNICODE ./configure
% env X_CFLAGS=-DUSE_UNICODE X_EXTRA_LIBS=-lxpg4 ./configure

・初期化
FXApp.cpp: FXApp::openDisplay()
XUInit()を埋め込む
XOpenDisplay()の後にXUIMOpen()を追加
displayに対してdisplay_infoを追加

・単純な置き換え
FXWindow.cpp: XDestroyWindow() -&gt; XUDestroyWindow()
FXApp.cpp: XCloseDisplay() -&gt; XUCloseDisplay()
display_infoもNULLにする。


  ---- 表示 ----

・フレンドクラスの追加
FXFont.h: friend class FXDCWindow;

・文字表示のUTF-8化
FXDCWindow.cpp: XDraw*String() -&gt; XUutf8DrawString()

・文字幅処理の置き換え
FXFont.cpp: XTextWidth()   -&gt; XUutf8TextWidth()
FXFont.cpp: XTextExtents() -&gt; XUutf8TextExtents()

・文字長取得を追加
FXText.cpp: FXText::wcharLen(), FXText::wcharRLen()

・ワイド文字関数を追加
FXFont.cpp: FXFont::getWCharWidth()
FXText.cpp: FXText::getWChar(), FXText::wcharWidth()

・文字長処理を調節
FXText.cpp: 色々
FXTextField.cpp: FXTextField::drawCursor(), FXTextField::index()
getChar()とcharWidth()を使う部分を修正

・キャレット移動
FXText.cpp, FXTextField.cpp: 
onCmdCursorLeft(), onCmdCursorRight()

・文字削除
FXText.cpp, FXTextField.cpp: 
onCmdBackspace(), onCmdDelete()


  ---- XIM ----

・フレンドクラスの追加
FXFont.h: friend class FXWindow;

・文字列を受け付け
fxdefs.h: FXEventにchar*を追加
FXText.cpp: FXText::onKeyPress()
FXTextField.cpp: FXTextField::onKeyPress()

・XIC処理関数
FXWindow.h: FXWindow::setIM(), FXWindow::unsetIM()を追加

・イベント処理
FXApp.cpp: XLookupString() -&gt; XUutf8LookupString()
Pressに対応しないReleaseは無視する。

・XICオン
FXText.cpp: FXText::drawCursor()
FXTextField.cpp: FXTextField::drawCursor()
キャレットを表示する時にsetIM()

・XICオフ
FXText.cpp: FXText::onFocusOut()
FXTextField.cpp: FXTextField::onFocusOut()
フォーカスが外れた時にunsetIM()


  ---- uinput ----

変な所で有効にならないように
XIMが有効なウィンドウでだけ有効にする。
マウスをクリックしたりフォーカスが外れたらキャンセル。

・エラー処理
FXApp.cpp: xerrorhandler()

・サーバに接続
FXWindow.cpp: XCreateWindow()の後にXUUISearch()

・イベント処理
FXApp.cpp:
キー入力後にXUUISend()
ClientMessageでの処理(setSrvとinput)
</para>
</node>
<node title="Wide Studio">
<para>
  ---- 基本 ----

XIM関連は既に実装されているので特にXUnicodeを使わない。

・初期化
x11/WSDxappDev.cpp: WSDxappDev::initialize()
XUInit()を追加。重複しないようにフラグを付ける。

・解放
x11/WSDxappDev.cpp: WSDxappDev::initialize()
XUFreeInfoDisplay()
x11/WSDxwinDev.cpp: WSDxwinDev::destroyWindow(), setVisible()
XtDestroyWidget()の前にXUFreeIndoWindow()


  ---- 表示 ----

・文字表示のUTF-8化
x11/WSxcom.cpp: XDrawString() -&gt; XUDrawString()


  ---- uinput ----

変な所で有効にならないように
XIMが有効なウィンドウでだけ有効にする。
-&gt; できていないので聞く。

・エラー処理
x11/WSDxappDev.cpp: _ehandler()
</para>
</node>
</node>
</node>
</hds>
